source /usr/share/defaults/etc/profile
# barko
export PULSE_LATENCY_MSEC=400
export JAVA_HOME=/usr/lib64/openjdk-17
export PATH=/opt/lampp/bin:$JAVA_HOME/bin:$PATH
#
test -s ~/.alias && . ~/.alias || true
# === BACKUP & RESTORE ===
# Backup function — updated to avoid repeated copies on non-Unix filesystems
backup() {
  local SRC="${HOME}/"
  local DEST="/run/media/barko/BACKUPS/barko/"

  local -a EXCLUDES=(
    # add relative paths from $SRC to exclude, e.g. ".cache" "Downloads/largefile"
  )

  local -a RSYNC_EXCLUDE_ARGS=()
  for p in "${EXCLUDES[@]}"; do
    RSYNC_EXCLUDE_ARGS+=(--exclude="$p")
  done

  # detect destination filesystem (best-effort)
  local fstype=""
  if command -v findmnt >/dev/null 2>&1; then
    fstype=$(findmnt -n -o FSTYPE --target "$DEST" 2>/dev/null || true)
  elif command -v df >/dev/null 2>&1; then
    fstype=$(df -T "$DEST" 2>/dev/null | awk 'NR==2{print $2}' || true)
  fi

  local -a RSYNC_FS_OPTS=()
  case "$fstype" in
    vfat|fat|msdos|exfat|ntfs)
      RSYNC_FS_OPTS+=(--no-perms --no-owner --no-group --modify-window=1)
      ;;
  esac

  # Safety: ensure destination exists and looks like a mounted backup
  if [ ! -d "$DEST" ]; then
    echo "Napaka: ciljni imenik '$DEST' ne obstaja. Preverite, ali je pogon montiran." >&2
    return 1
  fi

  # Check whether $DEST is actually on a mounted filesystem. Prefer
  # 'findmnt --target' (returns success if the path lies on any mounted FS).
  if command -v findmnt >/dev/null 2>&1; then
    if ! findmnt --target "$DEST" >/dev/null 2>&1; then
      read -rp "Ciljni disk '$DEST' ni montiran ali ni dosegljiv. Nadaljujem in kopiram v lokalno mapo? [N/d] " confirm
      confirm=${confirm,,}
      case "$confirm" in
        d|da) echo "Nadaljujem (prepričaj se, da je to namenoma).";;
        *) echo "Backup preklican."; return 1;;
      esac
    fi
  elif command -v mountpoint >/dev/null 2>&1; then
    # Fallback: 'mountpoint' only reports true if the directory itself is a mount point.
    if ! mountpoint -q "$DEST"; then
      # If the directory appears empty, it's likely not mounted — warn and confirm.
      if [ -z "$(ls -A "$DEST" 2>/dev/null)" ]; then
        read -rp "Ciljni imenik '$DEST' je prazen ali ni montiran. Nadaljujem? [N/d] " confirm
        confirm=${confirm,,}
        case "$confirm" in
          d|da) echo "Nadaljujem (prepričaj se, da je to namenoma).";;
          *) echo "Backup preklican."; return 1;;
        esac
      fi
    fi
  else
    # No findmnt/mountpoint available — best-effort: warn if empty.
    if [ -z "$(ls -A "$DEST" 2>/dev/null)" ]; then
      read -rp "Ciljni imenik '$DEST' je prazen ali ni montiran. Nadaljujem? [N/d] " confirm
      confirm=${confirm,,}
      case "$confirm" in
        d|da) echo "Nadaljujem (prepričaj se, da je to namenoma).";;
        *) echo "Backup preklican."; return 1;;
      esac
    fi
  fi

  read -rp "Backup ${SRC} → ${DEST}? [D/N] " ans
  ans=${ans,,}
  case "$ans" in
    d|da)
      echo "Začenjam backup... "
      sudo rsync -a -z --delete --delete-excluded --info=progress2 \
        "${RSYNC_EXCLUDE_ARGS[@]}" "${RSYNC_FS_OPTS[@]}" "$SRC" "$DEST"
      rc=$?
      if [ $rc -eq 0 ]; then
        echo "Backup končan uspešno."
      else
        echo "Backup končal z napako (kod: $rc)."
      fi
      ;;
    *)
      echo "Backup preklican."
      ;;
  esac
}

restore() {
  local SRC="/run/media/barko/BACKUPS/barko/"
  local DEST="/home/barko/"
  local EXCLUDES=( "Games/" "Prejemi/" )

  # Safety checks: ensure source exists, is likely mounted and not empty
  if [ ! -d "$SRC" ]; then
    echo "Napaka: izvorni backup '$SRC' ne obstaja. Preverite, ali je pogon montiran." >&2
    return 1
  fi

  # Check whether $SRC is on a mounted filesystem. Prefer 'findmnt --target'.
  if command -v findmnt >/dev/null 2>&1; then
    if ! findmnt --target "$SRC" >/dev/null 2>&1; then
      echo "VARNOST: izvorni backup ni montiran ali ni dosegljiv. Restore z --delete lahko izbriše datoteke v $DEST." >&2
      read -rp "Res želite nadaljevati? [D/N] " ans
      ans=${ans,,}
      case "$ans" in
        d|da) echo "Nadaljujem (pazi!).";;
        *) echo "Restore preklican."; return 1;;
      esac
    fi
  elif command -v mountpoint >/dev/null 2>&1; then
    if ! mountpoint -q "$SRC"; then
      echo "VARNOST: izvorni backup ni montiran. Restore z --delete lahko izbriše datoteke v $DEST." >&2
      read -rp "Res želite nadaljevati? [D/N] " ans
      ans=${ans,,}
      case "$ans" in
        d|da) echo "Nadaljujem (pazi!).";;
        *) echo "Restore preklican."; return 1;;
      esac
    fi
  else
    # no findmnt/mountpoint: ensure directory not empty
    if [ -z "$(ls -A "$SRC" 2>/dev/null)" ]; then
      echo "VARNOST: izvorni backup je prazen ali nedosegljiv. Restore preklican." >&2
      return 1
    fi
  fi

  if [ -z "$(ls -A "$SRC" 2>/dev/null)" ]; then
    echo "Napaka: izvorna mapa '$SRC' je prazna. Možno je, da pogon ni montiran. Restore preklican." >&2
    return 1
  fi

  read -rp "Res želite obnoviti ${SRC} → ${DEST}? [D/N] " ans
  ans=${ans,,}
  case "$ans" in
    d|da)
      local rsync_exclude_args=()
      for e in "${EXCLUDES[@]}"; do
        rsync_exclude_args+=( --exclude="$e" )
      done

      echo "Predogled (rsync --dry-run) — prikazal bo, kaj bi bilo spremenjeno/izbrisano:" 
      sudo rsync -a -z --delete --info=progress2 --dry-run "${rsync_exclude_args[@]}" "$SRC" "$DEST"

      read -rp "Želite izvesti dejanski restore po ogledu? [D/N] " ans2
      ans2=${ans2,,}
      case "$ans2" in
        d|da)
          echo "Začenjam restore... (izključene: ${EXCLUDES[*]})"
          sudo rsync -a -z --delete --info=progress2 "${rsync_exclude_args[@]}" "$SRC" "$DEST"
          rc=$?
          if [ $rc -eq 0 ]; then
            echo "Restore končan uspešno."
          else
            echo "Restore končal z napako (kod: $rc)."
          fi
          ;;
        *)
          echo "Restore preklican po predogledu."; return 0;;
      esac
      ;;
    *)
      echo "Restore preklican.";;
  esac
}
# === BACKUP & RESTORE ===
gpt() {
  local prompt="$*"
  local response=$(curl -s https://api.openai.com/v1/chat/completions \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -d "{
      \"model\": \"gpt-5-mini\",
      \"messages\": [
        {
          \"role\": \"system\",
          \"content\": \"za računanje uporabi python knjižnice, za odgovore uporabi slovenščino, za valute uporabi EUR in znak €, za odgovore porabi do največ 250 znakov, bodi zelo kratek v odgovorih\"
        },
        {
          \"role\": \"user\",
          \"content\": \"${prompt}\"
        }
      ]
    }")
  echo "$response" | jq -r '.choices[0].message.content'
}
#
fixgd() {
    if [ -f "$1" ]; then
        sed -i 's/"showWatermark": true/"showWatermark": false/g' "$1"
        sed -i 's/"showGDevelopSplash": true/"showGDevelopSplash": false/g' "$1"
        sed -i 's/"showProgressBar": true/"showProgressBar": false/g' "$1"
        echo "Datoteka '$1' je bila uspešno posodobljena."
    else
        echo "Napaka: Datoteka '$1' ne obstaja."
    fi
}
export EDITOR=nano
export VISUAL=nano
toutf8() {
    for file in *.srt; do
        # Zaznaj kodiranje
        encoding=$(enca -i "$file")

        if [ "$encoding" != "UTF-8" ]; then
            # Pretvori v UTF-8 v začasno datoteko
            if iconv -f "$encoding" -t "UTF-8" "$file" -o "${file}.tmp"; then
                mv "${file}.tmp" "$file"
                echo "$file pretvorjen v UTF-8"
            else
                echo "Napaka pri pretvorbi: $file" >&2
                continue
            fi
        else
            echo "$file je že v UTF-8"
        fi

        # Odstrani <i> in </i>
        sed -i 's/<i>//g; s/<\/i>//g' "$file"
    done
}
alias df='df -H'
alias updatedb='sudo updatedb'
alias locate='sudo locate'
alias bios='sudo dmidecode -s bios-version'
alias reboot='sudo reboot'
alias nopassword='sudo usermod -p "" $USER'
alias setpassword='sudo passwd $USER'
alias tar='tar -cvzf'
alias untar='tar -xvzf'
alias makeiso='mkisofs -iso-level 3 -o makeiso.iso .'
alias spremembe="find . -type f -printf '%T@ %p\n' | sort -n | tail -n 10"
alias icons_restore="cp /home/$USER/.local/share/gvfs-metadata/home.$USER /home/$USER/.local/share/gvfs-metadata/home"
alias icons_backup="cp /home/$USER/.local/share/gvfs-metadata/home /home/$USER/.local/share/gvfs-metadata/home.$USER"
alias fixopenfolder='xdg-mime default org.gnome.Nautilus.desktop inode/directory'
alias fixflatpakicons='flatpak --user override --filesystem=~/.local/share/icons/:ro'
alias fixflatpak='flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo'
alias fixicons='gsettings set org.gnome.desktop.interface icon-theme "Hatter"'
alias fixmaxsound="gsettings set org.gnome.desktop.sound allow-volume-above-100-percent 'true'"
alias fixwait="gsettings set org.gnome.mutter check-alive-timeout 60000"
alias fixlaptoplid="sudo mkdir -p '/etc/systemd/logind.conf.d'; echo -e \"[Login]\\nHandleLidSwitch=ignore\" | sudo tee '/etc/systemd/logind.conf.d/99-laptop-server.conf' > '/dev/null'"
alias fixaddtog1="if grep -q wheel /etc/group; then sudo usermod -a -G wheel $USER; else echo 'Skupina wheel ne obstaja'; fi"
alias fixaddtog2="if grep -q vboxusers /etc/group; then sudo usermod -a -G vboxusers $USER; else echo 'Skupina vboxusers ne obstaja'; fi"
alias fixaddtog3="if grep -q gamemode /etc/group; then sudo usermod -a -G gamemode $USER; else echo 'Skupina gamemode ne obstaja'; fi"
alias fixaddtog4="if grep -q libvirt /etc/group; then sudo usermod -a -G libvirt,kvm,qemu $USER; else echo 'Skupina libvirt ne obstaja'; fi"
alias fixwindowbuttons='gsettings set org.gnome.desktop.wm.preferences button-layout "appmenu:minimize,maximize,close"'
alias fixwinesound='mkdir -p /home/$USER/.local/share/pipewire/pipewire-pulse.conf.d; echo "pulse.rules = [{matches = [{application.process.binary = \"wine64-preloader\" }], actions = {update-props = {pulse.min.quantum = 1024/48000}}}] " | tee /home/$USER/.local/share/pipewire/pipewire-pulse.conf.d/wine_gaming.conf > /dev/null'
alias fixwinesound_sys='sudo mkdir -p /usr/share/pipewire/pipewire-pulse.conf.d; echo "pulse.rules = [{matches = [{application.process.binary = \"wine64-preloader\" }], actions = {update-props = {pulse.min.quantum = 1024/48000}}}] " | sudo tee /usr/share/pipewire/pipewire-pulse.conf.d/wine_gaming.conf > /dev/null'
alias fixlocalhost="sudo hostnamectl set-hostname namiznik"
alias fixzram='echo -e "[zram0]\nzram-size = min(ram, 4096)\ncompression-algorithm = zstd" | sudo tee /usr/lib/systemd/zram-generator.conf'
alias fixmaxmapcount='sudo mkdir -p /etc/sysctl.d; echo -e "vm.max_map_count = 2000000" | sudo tee /etc/sysctl.d/10-custom.conf'
alias fixkvm="sudo systemctl enable --now libvirtd"
alias fixnmwos="sudo systemctl disable NetworkManager-wait-online.service"
alias fixterminal="gsettings set org.gnome.desktop.default-applications.terminal exec '/usr/bin/ptyxis'"
alias fixvirbox='echo "options kvm enable_virt_at_load=0" | sudo tee /usr/lib/modprobe.d/virtualbox.conf'
alias fixm2026='sudo ln -s /opt/smfp-common/printer/bin/rastertospl /usr/lib/cups/filter/rastertosplc'
alias fixdbox="sudo touch /etc/subuid /etc/subgid && sudo chmod 644 /etc/subuid /etc/subgid && sudo usermod --add-subuids 100000-165536 --add-subgids 100000-165536 $USER"
alias fixpodman1='sudo touch /etc/subuid /etc/subgid; sudo usermod --add-subuids 100000-165535 --add-subgids 100000-165535 $USER'
alias fixpodman2='mkdir -p $HOME/.config/containers && echo -e "[engine]\nruntime = \"crun\"" > $HOME/.config/containers/containers.conf'
alias fixwaydnet='sudo ufw allow 53 && sudo ufw allow 67 && sudo ufw default allow FORWARD'
alias fixbtrfs='sudo btrfs quota disable /'
alias fixsteamoldcpu1='echo "STEAM_HACK_IGNORE_HWCAPS=1" | sudo tee /etc/environment'
# reboot
alias fixsteamoldcpu2='sudo ldconfig -X'
cleanoldkernels() { current=$(uname -r | sed "s/-.*//"); kernels=($(eopkg list-installed | awk '/^linux-/{print $1}' | sort -V -r)); active=""; for k in "${kernels[@]}"; do ver=${k#linux-}; [[ "$current" == "$ver"* ]] && { active=$k; break; }; done; [[ -z "$active" ]] && return; [[ "${kernels[0]}" == "$active" ]] && penultimate=${kernels[1]} || penultimate=${kernels[0]}; for k in "${kernels[@]}"; do [[ "$k" != "$active" && "$k" != "$penultimate" ]] && sudo eopkg remove -y "$k"; done; }
alias toac3='f(){ [ -z "$1" ] && echo "⚠️ Uporaba: dts2ac3 <datoteka.mkv>" && return 1; [ ! -f "$1" ] && echo "❌ Napaka: datoteka ne obstaja." && return 1; ffmpeg -i "$1" -map 0 -c:v copy -c:a ac3 -b:a 640k -c:s copy "${1%.*}_ac3.mkv"; }; f'
alias spisek='ls -1d */ | sed "s:/$::" | awk "{print \"flatpak install -y flathub \" \$0}" > spisek'
alias db='distrobox'
# debian - ker se kar naprej motim
alias ubuntu='distrobox enter ubuntu'
alias debian='distrobox enter debian'
alias fedora='distrobox enter fedora'
alias xampp="sudo /opt/lampp/xampp"
alias xs="echo 'Re/Start xampp...'; xampp restart &>/dev/null; echo 'Ok'"
alias xst="echo 'Stop xampp...'; xampp stop &>/dev/null; echo 'Ok'"
alias fixrtw88='sudo mkdir -p /etc/modprobe.d && echo "blacklist rtw88_8822bu" | sudo tee /etc/modprobe.d/rtw8822bu.conf > /dev/null'
alias fixjava='sudo rm /usr/bin/java; sudo ln -s /usr/lib64/openjdk-17/bin/java /usr/bin/java'
alias fixspicecap='f=$(find /usr -name spice-client-glib-usb-acl-helper 2>/dev/null | head -n1) && (getcap "$f" | grep -q cap && sudo setcap -r "$f" && echo "✔ Capabilities removed from $f" || echo "ℹ️  No capabilities to remove in $f")'
alias fixmailspring='xdg-mime default mailspring.desktop x-scheme-handler/mailto'
alias fixnetstat='sudo ln -s /usr/sbin/ss /usr/bin/netstat'
alias fixeopkg='sudo eopkg rmo; sudo eopkg clean; sudo eopkg delete-cache; sudo eopkg -y rebuild-db; sudo eopkg up'
#
exportpod() {
  if [ -z "$1" ]; then
    echo "Uporaba: exportpod <ime_kontejnerja>"
  elif podman container exists "$1"; then
    podman export -o "$1.tar" "$1"
  else
    echo "Kontejner '$1' ne obstaja"
  fi
}
#
importpod() {
  if [ -z "$1" ]; then
    echo "Uporaba: importpod <ime_datoteke.tar>"
  elif [ -f "$1" ]; then
    podman import "$1"
  else
    echo "Datoteka '$1' ne obstaja"
  fi
}
#
ffsys() {
  mkdir -p srts && \
  find . -maxdepth 1 -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" \) | while read -r video; do
    srt="${video%.*}.srt"
    [ -f "$srt" ] || continue
    cp "$srt" srts/ && ffsubsync "$video" -i "$srt" -o "$srt"
  done
}
#
function fixbroken {
  ( sudo eopkg check 2>&1 || true ) | tee /dev/stderr \
    | awk '/^Broken/ { print $4 } /Cannot calculate SHA1 hash of/ { print $NF }' \
    | while read -r item; do
        pkg=$(eopkg whatprovides "$item" 2>/dev/null | head -n1)
        if [ -n "$pkg" ]; then
          echo "Reinstalliram: $pkg"
          sudo eopkg it --reinstall "$pkg"
        else
          echo "Opozorilo: ne najdem paketa za »$item«"
        fi
      done
}
#
# Improved compilepy: checks for PyInstaller, uses temp directories and cleans up
compilepy() {
    local file="$1"
    if [ -z "$file" ]; then
        echo "Usage: compilepy <script.py> [pyinstaller-opts]" >&2
        return 1
    fi
    if [ ! -f "$file" ]; then
        echo "Error: file not found: $file" >&2
        return 1
    fi

    local filename
    filename="$(basename "$file" .py)"

    # find pyinstaller (either executable or module)
    local -a pyinstaller_cmd
    if command -v pyinstaller >/dev/null 2>&1; then
        pyinstaller_cmd=(pyinstaller)
    elif python3 -c "import PyInstaller" >/dev/null 2>&1; then
        pyinstaller_cmd=(python3 -m PyInstaller)
    elif python -c "import PyInstaller" >/dev/null 2>&1; then
        pyinstaller_cmd=(python -m PyInstaller)
    else
        echo "Error: PyInstaller not found. Install with: python3 -m pip install --user pyinstaller" >&2
        return 1
    fi

    local tmpdir
    tmpdir="$(mktemp -d)" || { echo "Failed to create temp dir" >&2; return 1; }
    trap 'rm -rf -- "$tmpdir"' EXIT

    local distdir="$tmpdir/dist"
    local workdir="$tmpdir/build"
    local specdir="$tmpdir"
    mkdir -p "$distdir" "$workdir" "$specdir" || { echo "Failed to create build dirs" >&2; return 1; }

    echo "Compiling $file..."
    shift
    "${pyinstaller_cmd[@]}" --onefile --windowed --distpath "$distdir" --workpath "$workdir" --specpath "$specdir" "$@" "$file"
    local rc=$?
    if [ $rc -ne 0 ]; then
        echo "PyInstaller failed (exit $rc)" >&2
        return $rc
    fi

    local exe="$distdir/$filename"
    if [ ! -f "$exe" ] && [ -f "$exe.exe" ]; then
        exe="$exe.exe"
    fi
    if [ ! -f "$exe" ]; then
        echo "Error: executable not created in $distdir" >&2
        return 1
    fi

    local target="./$filename"
    if [ -f "$target" ]; then
        local bak="${target}.$(date +%s).bak"
        echo "Note: $target exists, backing up to $bak"
        mv -f "$target" "$bak" || { echo "Failed to backup existing executable" >&2; return 1; }
    fi

    mv -f "$exe" "$target" || { echo "Failed to move executable" >&2; return 1; }
    echo "Executable created: $target"
    return 0
}
#
get_wmclass_interactive() {
  # izberi okno
  local wid=$(xdotool selectwindow)
  # vrni razred
  xprop -id "$wid" WM_CLASS | awk -F\" '{ print $4 }'
}
dupes() {
  # =========================================
  # Orodje za odstranjevanje .ogg duplikatov
  # Primarno: ARTIST+TITLE iz tagov
  # Fallback/alternativa: ujemanje po imenu datoteke (normalizirano)
  # Ohranimo najdaljši posnetek (po trajanju)
  # =========================================

  show_help() {
    cat <<'EOF'
Uporaba:
  dupes -s [MAPA] [možnosti]

Možnosti:
  -s, --start          ZAČNI iskanje in obdelavo (obvezno)
  --dry-run            Ne briši, samo izpiši, kaj bi šlo v koš
  --force              Briši brez potrditve
  -v,  --verbose       Podroben izpis odločitev
  --no-progress        Skrij sprotni status
  --stats-every N      Pogostost posodobitev napredka (privzeto: 25)
  --mode MODE          Način ujemanja duplikatov:
                       tags  = samo po tagih ARTIST+TITLE
                       name  = samo po imenu datoteke
                       both  = najprej tags, sicer name (privzeto)
  --show-keys          Na koncu pokaži nekaj ključev (za diagnostiko)
  -h, --help           Pokaži to pomoč

Primeri:
  dupes -s --mode both                 # tags ali (če manjkajo) po imenu
  dupes -s /pot --dry-run --verbose    # preizkus, podrobni logi
  dupes -s --mode name                 # samo po imenu datotek

Opombe:
  - Potrebuje ffprobe (paket ffmpeg).
  - "Ime" se normalizira: odstrani oklepaje/oznake (npr. "(live)", "[remastered]"),
    "feat./ft./featuring", različne pomišljaje, diakritiko in presežne presledke.
  - Hevristika imena:
      "Izvajalec - Naslov" ali "Izvajalec – Naslov" (če je točno en pomišljaj).
    V drugih primerih se celoten naziv obravnava kot naslov brez izvajalca.
EOF
  }

  # -------------------------------
  # Pomožne: slugify (ASCII, lower)
  # -------------------------------
  _slugify() {
    # → niz: pretvori v ASCII (TRANSLIT), zamenjaj ne-alfanumerične v presledek,
    # strni presledke, odreži robove, v lower-case.
    # opomba: iconv je del glibc (tudi na Solusu)
    LC_ALL=C \
    iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null \
    | sed "s/['\"]/ /g" \
    | tr -c '[:alnum:]' ' ' \
    | tr '[:upper:]' '[:lower:]' \
    | sed 's/[[:space:]]\+/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//'
  }

  # -----------------------------------------
  # Pomožne: normaliziraj "ime skladbe" iz file name
  # -----------------------------------------
  _key_from_filename() {
    local fbase="$1"
    # brez končnice
    local stem="${fbase%.*}"

    # normaliziraj različne pomišljaje v navaden " - "
    stem=$(printf '%s' "$stem" | sed 's/[–—‐-–]/-/g')

    # odstrani vse oklepajne opombe ((), [], {})
    stem=$(printf '%s' "$stem" | sed 's/([^(]*)//g; s/\[[^]]*\]//g; s/{[^}]*}//g')

    # odstrani “feat.”, “ft.”, “featuring” ipd. (in morebitno nadaljevanje)
    stem=$(printf '%s' "$stem" | sed -E 's/[[:space:]]+(feat\.|ft\.|featuring)[[:space:]].*$//I')

    # preslikaj podčrtaje v presledke, strni presledke
    stem=$(printf '%s' "$stem" | tr '_' ' ' | sed 's/[[:space:]]\+/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//')

    # heuristika: če je točno en '-' in ima ob straneh presledek → "Artist - Title"
    # (pazi: lahko je v imenu še kakšen '-'; zato raje štejemo pojavitev s sed)
    local dashcount
    dashcount=$(printf '%s' "$stem" | awk -F' - ' '{print NF-1}')
    local artist="" title=""

    if [ "$dashcount" -eq 1 ]; then
      artist=$(printf '%s' "$stem" | awk -F' - ' '{print $1}')
      title=$(printf '%s' "$stem" | awk -F' - ' '{print $2}')
    else
      # poskusi še z navadnim '-' brez presledkov okrog
      dashcount=$(printf '%s' "$stem" | awk -F'-' '{print NF-1}')
      if [ "$dashcount" -eq 1 ]; then
        artist=$(printf '%s' "$stem" | awk -F'-' '{print $1}')
        title=$(printf '%s' "$stem" | awk -F'-' '{print $2}')
      else
        # brez jasnega ločila: vse je "title"
        title="$stem"
      fi
    fi

    # slugify oba
    local akey tkey
    akey=$(printf '%s' "$artist" | _slugify)
    tkey=$(printf '%s' "$title"  | _slugify)
    printf '%s|%s' "$akey" "$tkey"
  }

  # -------------------
  # Brez argumentov → help
  # -------------------
  [ $# -eq 0 ] && { show_help; return 0; }

  local dir="."
  local dryrun=0 force=0 started=0
  local verbose=0 show_progress=1 stats_every=25
  local mode="both" show_keys=0

  # parser
  while [ $# -gt 0 ]; do
    case "$1" in
      -s|--start) started=1; shift ;;
      --dry-run)  dryrun=1; shift ;;
      --force)    force=1;  shift ;;
      -v|--verbose) verbose=1; shift ;;
      --no-progress) show_progress=0; shift ;;
      --stats-every)
        shift
        [[ "$1" =~ ^[0-9]+$ ]] || { echo "Napaka: --stats-every potrebuje celo število." >&2; return 2; }
        stats_every="$1"; shift ;;
      --mode)
        shift
        case "$1" in
          tags|name|both) mode="$1"; shift ;;
          *) echo "Napaka: --mode mora biti tags|name|both" >&2; return 2 ;;
        esac ;;
      --show-keys) show_keys=1; shift ;;
      -h|--help)  show_help; return 0 ;;
      --) shift; break ;;
      -*)
        echo "Neznana možnost: $1" >&2
        echo "Glej: dupes --help" >&2
        return 2 ;;
      *)
        dir="$1"; shift ;;
    esac
  done

  [ $started -ne 1 ] && { echo "Manjka -s/--start. Glej: dupes --help" >&2; return 2; }
  command -v ffprobe >/dev/null 2>&1 || { echo "Napaka: ffprobe ni nameščen (sudo eopkg it ffmpeg)." >&2; return 2; }
  [ -d "$dir" ] || { echo "Napaka: mapa '$dir' ne obstaja." >&2; return 2; }

  shopt -s nullglob

  # zberi .ogg, da imamo total in % napredek
  local -a files
  while IFS= read -r -d '' f; do files+=( "$f" ); done < <(find "$dir" -type f -iname '*.ogg' -print0)
  local total=${#files[@]}
  [ "$total" -eq 0 ] && { echo "Ni .ogg datotek v: $dir"; return 0; }

  # stanje
  local scanned=0 tagged=0 named=0 skipped=0
  declare -A bestfile bestdur
  declare -a todel
  declare -a dbgkeys

  _print_status() {
    [ $show_progress -eq 0 ] && return 0
    local groups=${#bestfile[@]}
    local delcount=${#todel[@]}
    local keep=$groups
    local pct=0
    [ "$total" -gt 0 ] && pct=$(( scanned * 100 / total ))
    printf "\r[%3d%%] prebrano:%-6d tags:%-6d imena:%-6d preskočenih:%-6d skupin:%-6d za-brisati:%-6d obdržanih:%-6d" \
      "$pct" "$scanned" "$tagged" "$named" "$skipped" "$groups" "$delcount" "$keep"
  }

  # glavna zanka
  for f in "${files[@]}"; do
    scanned=$((scanned+1))

    local use_key="" key_src=""
    local artist title akey tkey key dur

    if [ "$mode" != "name" ]; then
      # poskusi TAG-e
      artist=$(ffprobe -v error -show_entries format_tags=artist -of default=nw=1:nk=1 "$f" 2>/dev/null)
      title=$(ffprobe -v error -show_entries format_tags=title  -of default=nw=1:nk=1 "$f" 2>/dev/null)
      if [ -n "$artist" ] && [ -n "$title" ]; then
        akey=$(printf '%s' "$artist" | _slugify)
        tkey=$(printf '%s' "$title"  | _slugify)
        use_key="$akey|$tkey"
        key_src="tags"
        tagged=$((tagged+1))
      fi
    fi

    if [ -z "$use_key" ] && [ "$mode" != "tags" ]; then
      # FALLBACK: po imenu
      local base
      base=$(basename -- "$f")
      use_key=$(_key_from_filename "$base")
      key_src="name"
      # zaznaj “praznega” ključ (npr. samo |title ali celo prazen niz)
      [ -n "$use_key" ] && named=$((named+1))
    fi

    # če nismo dobili uporabnega ključa, preskoči
    if [ -z "$use_key" ] || [ "$use_key" = "|" ]; then
      skipped=$((skipped+1))
      [ $verbose -eq 1 ] && echo -e "\n[SKIP] Brez uporabnega ključa → $f"
      [ $show_progress -eq 1 ] && [ $((scanned % stats_every)) -eq 0 ] && _print_status
      continue
    fi

    # trajanje
    dur=$(ffprobe -v error -show_entries format=duration -of default=nw=1:nk=1 "$f" 2>/dev/null)
    awk 'BEGIN{exit(ARGV[1]==ARGV[1]+0?0:1)}' "$dur" >/dev/null 2>&1 || dur=0

    # diagnostika ključev (naključno nekaj zabeležimo)
    if [ "$show_keys" -eq 1 ] && [ "${#dbgkeys[@]}" -lt 12 ]; then
      dbgkeys+=( "$(printf '%s  |  %s' "$use_key" "$key_src")" )
    fi

    if [ -z "${bestfile[$use_key]+set}" ]; then
      bestfile["$use_key"]="$f"
      bestdur["$use_key"]="$dur"
      [ $verbose -eq 1 ] && echo -e "\n[KEEP:$key_src] $(basename -- "$f")  (dur=${dur}s)  key=$use_key"
    else
      if awk -v a="$dur" -v b="${bestdur[$use_key]}" 'BEGIN{exit(a>b?0:1)}'; then
        [ $verbose -eq 1 ] && echo -e "\n[REPLACE:$key_src] $(basename -- "$f") (${dur}s) > $(basename -- "${bestfile[$use_key]}") (${bestdur[$use_key]}s)"
        todel+=( "${bestfile[$use_key]}" )
        bestfile["$use_key"]="$f"
        bestdur["$use_key"]="$dur"
      else
        [ $verbose -eq 1 ] && echo -e "\n[DROP:$key_src] $(basename -- "$f") (${dur}s) <= ${bestdur[$use_key]}s"
        todel+=( "$f" )
      fi
    fi

    [ $show_progress -eq 1 ] && [ $((scanned % stats_every)) -eq 0 ] && _print_status
  done

  [ $show_progress -eq 1 ] && { _print_status; echo; }

  if [ "${#todel[@]}" -eq 0 ]; then
    echo "Ni najdenih duplikatov (po načinu: $mode)."
    if [ "$show_keys" -eq 1 ] && [ "${#dbgkeys[@]}" -gt 0 ]; then
      echo "Primeri uporabljenih ključev:"
      printf '  %s\n' "${dbgkeys[@]}"
    fi
    return 0
  fi

  echo "---------------------------------------------"
  echo "POVZETEK (način: $mode):"
  echo "  Skupaj .ogg:                $total"
  echo "  Prebranih:                  $scanned"
  echo "  Uporabni TAG-i:             $tagged"
  echo "  Uporabna imena:             $named"
  echo "  Preskočenih:                $skipped"
  echo "  Skupin (unikatnih ključev): ${#bestfile[@]}"
  echo "  Za brisanje:                ${#todel[@]}"
  echo "---------------------------------------------"

  if [ "$show_keys" -eq 1 ] && [ "${#dbgkeys[@]}" -gt 0 ]; then
    echo "Primeri ključev (key | izvor):"
    printf '  %s\n' "${dbgkeys[@]}"
    echo "---------------------------------------------"
  fi

  for f in "${todel[@]}"; do
    echo "DEL → $f"
  done

  if command -v du >/dev/null 2>&1; then
    echo
    echo "Skupna velikost za odstraniti:"
    du -ch -- "${todel[@]}" 2>/dev/null | tail -n1
  fi

  if [ "$dryrun" -eq 1 ]; then
    echo
    echo "DRY-RUN: nič ni bilo izbrisano."
    return 0
  fi

  if [ "$force" -ne 1 ]; then
    echo
    read -r -p "Želiš izbrisati te datoteke? [y/N] " ans
    case "$ans" in
      y|Y|yes|YES) ;;
      *) echo "Preklicano."; return 0 ;;
    esac
  fi

  local fail=0
  for f in "${todel[@]}"; do
    rm -f -- "$f" || { echo "Neuspeh brisanja: $f" >&2; fail=1; }
  done

  if [ $fail -eq 0 ]; then
    echo "Končano. Duplikati odstranjeni, najdaljše verzije ohranjene."
  else
    echo "Delno končano (nekaterih datotek ni bilo mogoče izbrisati)." >&2
    return 1
  fi
}
alias py='python3 $1'
alias wd_restart='sudo systemctl restart waydroid-container.service'
alias wifi-power-disable='echo -e "[connection]\nwifi.powersave = 2" | sudo tee /etc/NetworkManager/conf.d/wifi-powersave-off.conf > /dev/null && sudo systemctl restart NetworkManager'
function fixtmp {
    if [ "$1" = "soft" ]; then
        echo "Čistim /tmp po pravilih (systemd-tmpfiles)..."
        sudo systemd-tmpfiles --clean || true
    elif [ "$1" = "hard" ]; then
        echo "BRIŠEM VSE v /tmp (rm -rf)!"
        sudo rm -rf /tmp/* /tmp/.[!.]* /tmp/..?* 2>/dev/null || true
    else
        echo "Uporaba: fixtmp [soft|hard]"
    fi
}
# funkcija time_hms: izvede ukaz in izpiše pretečeni čas HH:MM:SS.mmm
time_hms() {
  local start end elapsed_ns elapsed_ms secs ms hh mm ss rc

  # Poskusimo z date +%s%N (Linux, GNU date)
  if date +%s%N >/dev/null 2>&1; then
    start=$(date +%s%N)
    "$@"
    rc=$?
    end=$(date +%s%N)
    elapsed_ns=$((end - start))
    secs=$((elapsed_ns / 1000000000))
    ms=$(((elapsed_ns / 1000000) % 1000))
  else
    # Fallback: meritev v milisekundah z python3 (macOS ali če ni GNU date)
    start=$(python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
)
    "$@"
    rc=$?
    end=$(python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
)
    elapsed_ms=$((end - start))
    secs=$((elapsed_ms / 1000))
    ms=$((elapsed_ms % 1000))
  fi

  hh=$((secs/3600))
  mm=$(( (secs%3600) / 60 ))
  ss=$((secs%60))

  printf "Elapsed: %02d:%02d:%02d.%03d\n" "$hh" "$mm" "$ss" "$ms"
  return $rc
}
###
compilepy() {
    local file="$1"
    if [ -z "$file" ]; then
        echo "Uporaba: compilepy <skript.py> [pyinstaller-argumenti]" >&2
        return 1
    fi
    if [ ! -f "$file" ]; then
        echo "Napaka: datoteka ni najdena: $file" >&2
        return 1
    fi

    local filename
    filename="$(basename "$file" .py)"

    # poišči pyinstaller (izvršljiva datoteka ali modul)
    local -a pyinstaller_cmd
    if command -v pyinstaller >/dev/null 2>&1; then
        pyinstaller_cmd=(pyinstaller)
    elif python3 -c 'import PyInstaller' >/dev/null 2>&1; then
        pyinstaller_cmd=(python3 -m PyInstaller)
    elif python -c 'import PyInstaller' >/dev/null 2>&1; then
        pyinstaller_cmd=(python -m PyInstaller)
    else
        echo "Napaka: PyInstaller ni najden. Namestite ga: python3 -m pip install --user pyinstaller" >&2
        return 1
    fi

    # zagotovimo pip (preveri in po potrebi poskusi namestiti)
    local -a pip_cmd
    ensure_pip() {
        if python3 -m pip --version >/dev/null 2>&1; then
            pip_cmd=(python3 -m pip); return 0
        elif command -v pip3 >/dev/null 2>&1; then
            pip_cmd=(pip3); return 0
        elif command -v pip >/dev/null 2>&1; then
            pip_cmd=(pip); return 0
        fi
        # poskusimo z ensurepip
        if python3 -m ensurepip --upgrade >/dev/null 2>&1; then
            pip_cmd=(python3 -m pip); return 0
        fi
        # poskusimo namestiti preko apt (če je na voljo)
        if command -v apt-get >/dev/null 2>&1; then
            echo "pip ni najden; poskušam namestiti python3-pip preko apt (zahteva sudo)..." >&2
            if sudo apt-get update && sudo apt-get install -y python3-pip; then
                if command -v pip3 >/dev/null 2>&1; then pip_cmd=(pip3); return 0; fi
            fi
        fi
        echo "Ne najdem pip; ročno namestite pip ali uporabite virtualenv / pipx." >&2
        return 1
    }

    # preden kompiliramo, poskušamo namestiti manjkajoče odvisnosti, ki jih uvozi skripta
    local dir
    dir="$(dirname "$(realpath "$file")")"
    local reqfile="$dir/requirements.txt"
    if [ -f "$reqfile" ]; then
        ensure_pip || return 1
        echo "Namestim odvisnosti iz $reqfile..."
        "${pip_cmd[@]}" install --user -r "$reqfile" || echo "Namestitev iz $reqfile ni uspela" >&2
    else
        local modules
        modules=$(python3 - <<'PY' "$file"
import ast,sys
p=sys.argv[1]
try:
    s=open(p,'r',encoding='utf-8').read()
except Exception:
    sys.exit(0)
mods=set()
for n in ast.walk(ast.parse(s)):
    if isinstance(n, ast.Import):
        for a in n.names:
            mods.add(a.name.split('.')[0])
    elif isinstance(n, ast.ImportFrom):
        if n.module and not n.module.startswith('.'):
            mods.add(n.module.split('.')[0])
for m in sorted(mods):
    if m and m!='__future__':
        print(m)
PY
)
        local to_install=()
        local mod
        for mod in $modules; do
            # preskoči lokalne module (datoteke v isti mapi)
            if [ -f "$dir/$mod.py" ] || [ -d "$dir/$mod" ]; then
                continue
            fi
            # če se modul že uvozi, preskočimo
            if python3 -c "import $mod" >/dev/null 2>&1; then
                continue
            fi
            to_install+=("$mod")
        done
        if [ "${#to_install[@]}" -gt 0 ]; then
            ensure_pip || return 1
            # mapa za pogoste neusklajenosti imen paketov
            declare -A pkgmap=( [PIL]=Pillow [bs4]=beautifulsoup4 [skimage]=scikit-image [sklearn]=scikit-learn [cv2]=opencv-python [yaml]=PyYAML [Crypto]=pycryptodome )
            local pkgs=()
            for mod in "${to_install[@]}"; do
                pkg="${pkgmap[$mod]:-$mod}"
                pkgs+=("$pkg")
            done
            echo "Namestim manjkajoče pakete: ${pkgs[*]}"
            "${pip_cmd[@]}" install --user --upgrade "${pkgs[@]}" || echo "Namestitev nekaterih paketov ni uspela." >&2
            # preverimo, kateri še manjkajo
            local still_missing=()
            for mod in "${to_install[@]}"; do
                if ! python3 -c "import $mod" >/dev/null 2>&1; then
                    still_missing+=("$mod")
                fi
            done
            if [ "${#still_missing[@]}" -gt 0 ]; then
                echo "Upozorilo: še vedno manjkajo naslednji moduli: ${still_missing[*]}" >&2
                echo "Ročno jih namestite ali preverite imena paketov (npr. Pillow namesto PIL)." >&2
            fi
        else
            echo "Ni manjkajočih paketov; vse uvožene knjižnice so že nameščene."
        fi
    fi

    local tmpdir
    tmpdir="$(mktemp -d)" || { echo "Neuspešno ustvarjanje začasne mape" >&2; return 1; }
    trap 'rm -rf -- "$tmpdir"' EXIT

    local distdir="$tmpdir/dist"
    local workdir="$tmpdir/build"
    local specdir="$tmpdir"
    mkdir -p "$distdir" "$workdir" "$specdir" || { echo "Neuspešno ustvarjanje gradbenih map" >&2; return 1; }

    echo "Kompiliranje $file..."
    shift
    "${pyinstaller_cmd[@]}" --onefile --windowed --distpath "$distdir" --workpath "$workdir" --specpath "$specdir" "$@" "$file"
    local rc=$?
    if [ $rc -ne 0 ]; then
        echo "PyInstaller ni uspel (izhod $rc)" >&2
        return $rc
    fi

    local exe="$distdir/$filename"
    if [ ! -f "$exe" ] && [ -f "$exe.exe" ]; then
        exe="$exe.exe"
    fi
    if [ ! -f "$exe" ]; then
        echo "Napaka: izvršljiva datoteka ni bila ustvarjena v $distdir" >&2
        return 1
    fi

    local target="./$filename"
    if [ -f "$target" ]; then
        local bak="${target}.$(date +%s).bak"
        echo "Pozor: $target obstaja, premikam v $bak"
        mv -f "$target" "$bak" || { echo "Neuspešno premikanje obstoječega izvršljivega" >&2; return 1; }
    fi

    mv -f "$exe" "$target" || { echo "Neuspešno premikanje izvršljive datoteke" >&2; return 1; }
    echo "Izvršljiva datoteka ustvarjena: $target"
    return 0
}
###
# Kratek alias (po želji spremeni 't' v kaj drugega)
alias t=time_hms
alias fixvivaldi='xdg-mime default vivaldi-stable.desktop x-scheme-handler/vivaldi'
alias fixcubic='sudo mkdir -p /etc/sysctl.d && echo "net.ipv4.tcp_congestion_control = cubic" | sudo tee /etc/sysctl.d/99-cubic.conf && sudo sysctl --system'
alias rext='gsettings set org.gnome.shell disable-user-extensions true && gsettings set org.gnome.shell disable-user-extensions false'
alias fixspamremote='gsettings set org.gnome.mutter.wayland xwayland-disable-extension '\''["Xtest"]'\'''
alias free='free -g'
alias fixlampp='sudo cp /opt/lampp/etc/httpd.conf /opt/lampp/etc/httpd.conf.bak-$(date +%s) && sudo cp /opt/lampp/etc/proftpd.conf /opt/lampp/etc/proftpd.conf.bak-$(date +%s) && sudo perl -0777 -pe "s/^User daemon$/User barko/mg; s/^Group daemon$/Group barko/mg; s#DocumentRoot \"/opt/lampp/htdocs\"#DocumentRoot \"/home/barko/Namizje/www\"#g; s#<Directory \"/opt/lampp/htdocs\">#<Directory \"/home/barko/Namizje/www\">#g" -i /opt/lampp/etc/httpd.conf && sudo perl -0777 -pe "s/^User daemon$/User barko/mg" -i /opt/lampp/etc/proftpd.conf && echo "fixlampp: izvedeno"'
alias natisni='f() { if [ $# -eq 0 ]; then echo "Uporaba: natisni <datoteka>"; elif [ ! -f "$1" ]; then echo "Napaka: datoteka ne obstaja!"; else lpr "$@"; fi; }; f'
alias killant='killall -9 antigravity'
alias fixgnomedonate="gsettings set org.gnome.settings-daemon.plugins.housekeeping donation-reminder-enabled 'false'"
alias smrekca='(clear; trap "tput cnorm; clear; exit" INT TERM; tput civis; tree=( "          *" "         /***" "        /*****" "       /*******" "      /*********" "     /***********" "    /*************" "         |||" "         |||" ); colors=(31 32 33 34 35 36); while true; do clear; for line in "${tree[@]}"; do c=${colors[$RANDOM % ${#colors[@]}]}; printf "\e[%sm%s\e[0m\n" "$c" "$line"; done; echo; printf "\e[1;32m     Vesel božič!\e[0m\n"; sleep 0.5; done)'
#
alias myinstall_rm='sudo eopkg rm -y celluloid snapshot '
alias myinstall_dev='sudo eopkg it -y -c system.devel ccache gdb git linux-current-headers meson ninja gcc pkgconf libadwaita-devel libgtk-4-devel libgtksourceview5-devel curl-devel libjson-glib-devel libsodium-devel graphene-devel libgtk-3 libayatana-appindicator sqlite3 gstreamer-1.0-plugins-base gstreamer-1.0-plugins-good gstreamer-1.0-plugins-bad glib2-devel gobject-introspection-devel gettext-devel libgtkmm-4-devel'
alias myinstall='sudo eopkg it -y starship gnome-boxes diodon python3-tkinter pip waydroid gufw upx xdotool iw enca firejail binutils rhythmbox gnome-disk-utility plocate localsend rsync transmission yarn nodejs filezilla distrobox lutris steam jq mc neofetch sshpass openjdk-17'
#
alias fixall="myinstall_rm; myinstall; myinstall_dev; fixflatpak; fixspicecap; fixjava;  fixmaxmapcount; fixvirbox; fixflatpakicons; fixmaxsound; fixwait; fixaddtog1; fixaddtog2; fixaddtog3; fixaddtog4; wifi-power-disable;  fixcubic; fixspamremote"
alias nethogs='sudo nethogs'
alias e='sudo eopkg'
alias cleanup='sudo journalctl --vacuum-time=2d; sudo eopkg dc -y; sudo eopkg rmo -y; flatpak remove --unused -y'
alias upg='sudo eopkg upgrade -y; flatpak update -y'
if [ -z "$CONTAINER_ID" ] && [ "$TERM_PROGRAM" != "vscode" ]; then
    neofetch
fi
c() {
  copilot -i "$*"
}
eval "$(starship init bash)"
